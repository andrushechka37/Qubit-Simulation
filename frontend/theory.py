import streamlit as st
from pathlib import Path

st.markdown(
    """
## Биты и кубиты

Классический бит может принимать дискретные значения: 0 и 1. Например, отсутсвие или наличие заряда может трактоваться компьютером как 0 или 1.

"""
)

img_path = Path(__file__).resolve().parent / "images" / "7.jpg"
st.image(str(img_path), caption="...", use_container_width=True)

st.markdown(
    """
В свою очередь кубиты могут быть:

1) В определенном состоянии (либо 0, либо 1, как классический бит)
2) В состоянии суперпозиции (кубит является и нулем, и единицей одновременно, но с разными вероятностями).
"""
)

img_path = Path(__file__).resolve().parent / "images" / "2.jpg"
st.image(str(img_path), caption="...", use_container_width=True)

st.markdown(
    """
## Измерение кубитов

При измерении значения кубитов мы разрушаем его суперпозицию и получаем какое-либо состояние с некоторой вероятностью
"""
)

img_path = Path(__file__).resolve().parent / "images" / "3.jpg"
st.image(str(img_path), caption="...", use_container_width=True)

st.markdown(
    """
Таким образом мы можем влиять на вероятности кубита лишь до самого измерения. То есть мы можем записывать вероятности, воздействуя на кубит.


## Где используется
"""
)

st.markdown(
    """


Смысл програмирования на квантовом компьютере - настройка вероятностей таким образом, чтобы интересующий результат был наиболее вероятным. 


Плюсом такого подхода можно считать, что при добавлении одного бита мощность компьютера увеличивается вдвое. Это и даёт нам вот ту самую экспоненциальную скорость вычислений в квантовом компьютере.


Настраиваем вероятности наших кубитов по ходу программы так, чтобы правильный результат засветился на выходе с большей вероятностью, чем неправильный.

[Подробнее про это](https://davidbkemp.github.io/QuantumComputingArticle/)
"""
)


img_path = Path(__file__).resolve().parent / "images" / "8.jpg"
st.image(str(img_path), caption="...", use_container_width=True)
st.markdown(
    """
## Манипуляции с кубитами:
"""
)
img_path = Path(__file__).resolve().parent / "images" / "4.jpg"
st.image(str(img_path), caption="...", use_container_width=True)


st.markdown(
    """
Для влияния на вероятности кубитов используются логические операции

Только мы помним, что не имеем права читать наши кубиты не уничтожив — значит AND, OR и другие «читающие» опреторы нам не подходят.

Из классияческих операторов пока остается лишь NOT.

На самом деле гейтов NOT в квантовом компьютере не один, а три. Если посмотреть на сферу Блоха можно догадаться, что «развернуть» стрелочку на 180° можно тремя разными способами.

Потому версии гейта NOT так и называются — X, Y, Z. В реальном программировании в подавляющем большинстве случаев нам достаточно одного. NOT = X.
"""
)

img_path = Path(__file__).resolve().parent / "images" / "9.jpg"
st.image(str(img_path), caption="...", use_container_width=True)

st.markdown(
    """
Controlled NOT, CNOT или CX — контролируемое отрицание.
Применяется к двум кубитам. Как некий IF. Если первый из кубитов выпадёт в 1, ко второму автоматически применится гейт NOT. Если нет — ничего не изменится.

Это лишь пример одной из операций, про большее их количество рассказано во вкладках "Реализация" и "Статическая модель"

Пример использования данных операций будет во вкладке "Реализация"
"""
)
st.page_link("frontend/how_work.py", label="➡️ Реализация")
st.markdown(
    """
А также можно собственноручно попробовать данные взаимодействия с кубитами во вкладке "Статическая модель"
"""
)

st.page_link("frontend/static.py", label="➡️ Статическая модель")
